"Data that can be used as proof to validate notices and execute vouchers on the base layer blockchain"
type Proof {
  "Validity proof for an output"
  validity: OutputValidityProof!
  "Data that allows the validity proof to be contextualized within submitted claims, given as a payload in Ethereum hex binary format, starting with '0x'"
  context: String!
}

"Request submitted to the application to advance its state"
type Input {
  "Input identifier"
  id: String!
  "Input index starting from genesis"
  index: Int!
  "Address responsible for submitting the input"
  msgSender: String!
  "Timestamp associated with the input submission, as defined by the base layer's block in which it was recorded"
  timestamp: BigInt!
  "Number of the base layer block in which the input was recorded"
  blockNumber: BigInt!
  "Input payload in Ethereum hex binary format, starting with '0x'"
  payload: String!
  "Get voucher from this particular input given the voucher's index"
  voucher(index: Int!): Voucher!
  "Get notice from this particular input given the notice's index"
  notice(index: Int!): Notice!
  "Get report from this particular input given the report's index"
  report(index: Int!): Report!
  "Get vouchers from this particular input with support for pagination"
  vouchers(
    first: Int
    last: Int
    after: String
    before: String
  ): VoucherConnection!
  "Get notices from this particular input with support for pagination"
  notices(
    first: Int
    last: Int
    after: String
    before: String
  ): NoticeConnection!
  "Get reports from this particular input with support for pagination"
  reports(
    first: Int
    last: Int
    after: String
    before: String
  ): ReportConnection!
}

"Validity proof for an output"
type OutputValidityProof {
  "Output index for this output"
  outputIndex: Int!
  "Array of sibling hashes for merkle proof"
  outputHashesSiblings: [String!]!
}

"Representation of a transaction that can be carried out on the base layer blockchain, such as a transfer of assets"
type Voucher {
  "Voucher index within the context of the input that produced it"
  index: Int!
  "Input whose processing produced the voucher"
  input: Input!
  "Transaction destination address in Ethereum hex binary format (20 bytes), starting with '0x'"
  destination: String!
  "Transaction payload in Ethereum hex binary format, starting with '0x'"
  payload: String!
  "Value in wei to be transferred along with the voucher execution"
  value: String!
  "Whether the voucher has been executed on the base layer"
  executed: Boolean!
  "Transaction hash of the voucher execution, if executed"
  transactionHash: String
  "Proof object that allows this voucher to be validated and executed on the base layer blockchain"
  proof: VoucherProof
  "Application that generated this voucher"
  application: Application!
}

"Proof data for voucher validation and execution"
type VoucherProof {
  "Output index for this voucher"
  outputIndex: Int!
  "Array of sibling hashes for merkle proof"
  outputHashesSiblings: [String!]!
}

"Application information"
type Application {
  "Application identifier"
  id: String!
  "Application name"
  name: String!
  "Application contract address"
  address: String!
}

"Top level queries"
type Query {
  "Get input based on its identifier"
  input(id: String!): Input!
  "Get voucher based on its output index"
  voucher(outputIndex: Int!): Voucher!
  "Get notice based on its index"
  notice(noticeIndex: Int!, inputIndex: Int!): Notice!
  "Get report based on its index"
  report(reportIndex: Int!, inputIndex: Int!): Report!
  "Get inputs with support for pagination"
  inputs(
    first: Int
    last: Int
    after: String
    before: String
    where: InputFilter
  ): InputConnection!
  "Get vouchers with support for pagination"
  vouchers(
    first: Int
    last: Int
    after: String
    before: String
  ): VoucherConnection!
  "Get notices with support for pagination"
  notices(
    first: Int
    last: Int
    after: String
    before: String
  ): NoticeConnection!
  "Get reports with support for pagination"
  reports(
    first: Int
    last: Int
    after: String
    before: String
  ): ReportConnection!
}

"Pagination entry"
type NoticeEdge {
  "Node instance"
  node: Notice!
  "Pagination cursor"
  cursor: String!
}

"Pagination result"
type InputConnection {
  "Total number of entries that match the query"
  totalCount: Int!
  "Pagination entries returned for the current page"
  edges: [InputEdge!]!
  "Pagination metadata"
  pageInfo: PageInfo!
}

"Pagination result"
type VoucherConnection {
  "Total number of entries that match the query"
  totalCount: Int!
  "Pagination entries returned for the current page"
  edges: [VoucherEdge!]!
  "Pagination metadata"
  pageInfo: PageInfo!
}

"Informational statement that can be validated in the base layer blockchain"
type Notice {
  "Notice index within the context of the input that produced it"
  index: Int!
  "Input whose processing produced the notice"
  input: Input!
  "Notice data as a payload in Ethereum hex binary format, starting with '0x'"
  payload: String!
  "Proof object that allows this notice to be validated by the base layer blockchain"
  proof: Proof
}

"Pagination entry"
type ReportEdge {
  "Node instance"
  node: Report!
  "Pagination cursor"
  cursor: String!
}

"Pagination result"
type ReportConnection {
  "Total number of entries that match the query"
  totalCount: Int!
  "Pagination entries returned for the current page"
  edges: [ReportEdge!]!
  "Pagination metadata"
  pageInfo: PageInfo!
}

"Filter object to restrict results depending on input properties"
input InputFilter {
  "Filter only inputs with index lower than a given value"
  indexLowerThan: Int
  "Filter only inputs with index greater than a given value"
  indexGreaterThan: Int
}

scalar BigInt

"Pagination result"
type NoticeConnection {
  "Total number of entries that match the query"
  totalCount: Int!
  "Pagination entries returned for the current page"
  edges: [NoticeEdge!]!
  "Pagination metadata"
  pageInfo: PageInfo!
}

"Pagination entry"
type InputEdge {
  "Node instance"
  node: Input!
  "Pagination cursor"
  cursor: String!
}

"Page metadata for the cursor-based Connection pagination pattern"
type PageInfo {
  "Cursor pointing to the first entry of the page"
  startCursor: String
  "Cursor pointing to the last entry of the page"
  endCursor: String
  "Indicates if there are additional entries after the end curs"
  hasNextPage: Boolean!
  "Indicates if there are additional entries before the start curs"
  hasPreviousPage: Boolean!
}

"Application log or diagnostic information"
type Report {
  "Report index within the context of the input that produced it"
  index: Int!
  "Input whose processing produced the report"
  input: Input!
  "Report data as a payload in Ethereum hex binary format, starting with '0x'"
  payload: String!
}

"Pagination entry"
type VoucherEdge {
  "Node instance"
  node: Voucher!
  "Pagination cursor"
  cursor: String!
}

schema {
  query: Query
}
